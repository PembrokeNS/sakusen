#ifndef LIBSAKUSEN__HITPOINTS_H
#define LIBSAKUSEN__HITPOINTS_H

#include <sakusen/oarchive.h>
#include <sakusen/iarchive.h>

namespace sakusen {

/** \brief HitPoints class wrapping a uint32.
 *
 * This is primarily for type safety and encapsulation, but also allows us to
 * implement saturating arithmetic rather than relying on the undefined
 * overflow behaviour of unsigned integers.
 *
 * \note One might fondly imagine that uint16 would suffice for HitPoints, but
 * experience suggests otherwise.
 */
class HitPoints {
  private:
    uint32 hp;
  public:
    /** \brief Returns the maximal HitPoints value. */
    static HitPoints max() {
      return HitPoints(std::numeric_limits<uint32>::max());
    }

    /** \brief Default ctor acts just like the default ctor on an integer. */
    HitPoints() : hp() { }

    /** \brief Create a new HitPoints with the given value. */
    explicit HitPoints(uint32 x) : hp(x) { }

    /** \brief Cast back to uint32. */
    operator uint32 () const { return hp; }

    /** \brief Add two HitPoints, saturating on overflow. */
    HitPoints operator+(const HitPoints& right) const {
      if (hp + right.hp < hp)
        return HitPoints::max();
      else
        return HitPoints(hp + right.hp);
    }

    /** \brief Destructively increase HitPoints, saturating on overflow. */
    HitPoints& operator+=(const HitPoints& right) {
      if (hp + right.hp < hp)
        hp = std::numeric_limits<uint32>::max();
      else
        hp += right.hp;
      return *this;
    }

    /** \brief Subtract two HitPoints, saturating on underflow. */
    HitPoints operator-(const HitPoints& right) const {
      if (hp - right.hp > hp)
        return HitPoints(0);
      else
        return HitPoints(hp - right.hp);
    }

    /** \brief Destructively subtract two HitPoints, saturating on underflow. */
    HitPoints& operator-=(const HitPoints& right) {
      if (hp - right.hp > hp)
        hp = 0;
      else
        hp -= right.hp;
      return *this;
    }

    /** \brief Scale HitPoints by a double in the obvious way.
     *
     * \param factor Must be a non-negative number.
     */
    HitPoints operator*(const double factor) const {
      return HitPoints(uint32(hp * factor));
    }

    /** \brief Destructively scale HitPoints by a double. */
    HitPoints& operator*=(const double factor) {
      hp = uint32(hp * factor);
      return *this;
    }

    /** \brief Scale HitPoints by an integer, saturating on overflow. */
    HitPoints operator*(const uint32 factor) const {
      if (hp < std::numeric_limits<uint32>::max() / factor)
        return HitPoints(hp * factor);
      else
        return max();
    }

    /** \brief Destructively scale HitPoints by an integer, saturating on overflow. */
    HitPoints& operator*=(const uint32 factor) {
      if (hp < std::numeric_limits<uint32>::max() / factor)
        hp *= factor;
      else
        hp = std::numeric_limits<uint32>::max();
      return *this;
    }

    /** \brief Divide HitPoints by a double in the obvious way.
     *
     * \param divisor Must be a non-negative number.
     */
    HitPoints operator/(const double divisor) const {
      return HitPoints(uint32(hp / divisor));
    }

    /** \brief Destructively divide HitPoints by a double. */
    HitPoints& operator/=(const double divisor) {
      hp = uint32(hp / divisor);
      return *this;
    }

    /** \brief Divide HitPoints by an integer in the obvious way.
     *
     * \note Underflow is not possible on unsigned integer division.
     */
    HitPoints operator/(const uint32 divisor) const {
      return HitPoints(hp / divisor);
    }

    /** \brief Destructively divide HitPoints by an integer. */
    HitPoints& operator/=(const uint32 divisor) {
      hp /= divisor;
      return *this;
    }

    friend OArchive& operator<<(OArchive& out, const HitPoints& hp);
    friend IArchive& operator>>(IArchive& in, HitPoints& hp);
};

/** \brief Output to an OArchive.
 *
 * At the moment the output format is indistinguishable from a uint32.
 */
inline OArchive& operator<<(OArchive& out, const HitPoints& hp) {
  return (out << hp.hp);
}

/** \brief Input from an IArchive.  */
inline IArchive& operator>>(IArchive& in, HitPoints& hp) {
  return (in >> hp.hp);
}

/** \if false
 * \brief HitPoints intermediate value class wrapping a uint64.
 *
 * This class shouldn't be used directly, but is generated by HitPoints after
 * computations. It can then be automagically cast back to a HitPoints if you
 * use it again, or have further computations performed on it. The existence of
 * this class means you can do:
 * \code
 * HitPoints hp = HitPoints::max();
 * hp = (hp * 2) / 3;
 * \endcode
 * without getting the wrong result through overflow. You can also do:
 *
 * \code
 * HitPoints hp = HitPoints::max() - HitPoints(1);
 * hp = hp * 2;
 * \endcode
 * and thanks to the automatic conversion, \c hp will end up with the value of
 * HitPoints::max().
 * \endif
 */

}

#endif // LIBSAKUSEN__HITPOINTS_H

